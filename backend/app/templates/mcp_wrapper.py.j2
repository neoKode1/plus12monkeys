"""MCP Server wrapper for {{ repo_name }} ({{ repo_url }}).

Auto-generated by +12 Monkeys — wraps the external repository's functionality
as MCP tools so any LLM can call them via the Model Context Protocol.

Usage:
    pip install -r requirements.txt
    python mcp_server.py
"""

import asyncio
import importlib
import json
import logging
import os
import subprocess
import sys
from typing import Any, Dict, List, Optional

# ---------------------------------------------------------------------------
# MCP SDK imports  (pip install mcp)
# ---------------------------------------------------------------------------
from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import TextContent, Tool

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("{{ project_name }}-mcp")

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------
REPO_URL = "{{ repo_url }}"
REPO_DIR = os.environ.get("REPO_DIR", "./{{ repo_name }}")

app = Server("{{ project_name }}")


# ---------------------------------------------------------------------------
# Helper: ensure the wrapped repo is cloned and installed
# ---------------------------------------------------------------------------
def _ensure_repo():
    """Clone the repo if it doesn't exist locally, and install its deps."""
    if not os.path.isdir(REPO_DIR):
        logger.info("Cloning %s …", REPO_URL)
        subprocess.run(["git", "clone", REPO_URL, REPO_DIR], check=True)
    # Install Python deps if present
    req_path = os.path.join(REPO_DIR, "requirements.txt")
    if os.path.exists(req_path):
        subprocess.run(
            [sys.executable, "-m", "pip", "install", "-r", req_path, "-q"],
            check=True,
        )
    # Add repo to sys.path so we can import it
    if REPO_DIR not in sys.path:
        sys.path.insert(0, os.path.abspath(REPO_DIR))


_ensure_repo()

{% if entry_points %}
# ---------------------------------------------------------------------------
# Discovered entry points — import them
# ---------------------------------------------------------------------------
{% for ep in entry_points %}
# Entry point: {{ ep }}
{% endfor %}
{% endif %}

# ---------------------------------------------------------------------------
# Tool definitions — expose repo functionality via MCP
# ---------------------------------------------------------------------------

@app.list_tools()
async def list_tools() -> List[Tool]:
    """Advertise available tools to MCP clients."""
    return [
        Tool(
            name="run_{{ repo_name_safe }}",
            description="Run the main functionality of {{ repo_name }}. "
                        "Pass arguments as a JSON object.",
            inputSchema={
                "type": "object",
                "properties": {
                    "command": {
                        "type": "string",
                        "description": "The command or function to run inside {{ repo_name }}.",
                    },
                    "args": {
                        "type": "object",
                        "description": "Arguments to pass to the command.",
                        "default": {},
                    },
                },
                "required": ["command"],
            },
        ),
        Tool(
            name="list_{{ repo_name_safe }}_files",
            description="List the top-level files and directories in {{ repo_name }}.",
            inputSchema={
                "type": "object",
                "properties": {},
            },
        ),
        Tool(
            name="read_{{ repo_name_safe }}_file",
            description="Read the contents of a file inside {{ repo_name }}.",
            inputSchema={
                "type": "object",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "Relative path inside the repo.",
                    },
                },
                "required": ["path"],
            },
        ),
    ]


@app.call_tool()
async def call_tool(name: str, arguments: Dict[str, Any]) -> List[TextContent]:
    """Handle incoming MCP tool calls."""

    if name == "run_{{ repo_name_safe }}":
        cmd = arguments.get("command", "")
        args = arguments.get("args", {})
        try:
            result = subprocess.run(
                [sys.executable, "-c", f"import runpy; runpy.run_path('{REPO_DIR}/{cmd}')"],
                capture_output=True, text=True, timeout=60,
            )
            output = result.stdout or result.stderr or "(no output)"
            return [TextContent(type="text", text=output[:4000])]
        except Exception as exc:
            return [TextContent(type="text", text=f"Error: {exc}")]

    elif name == "list_{{ repo_name_safe }}_files":
        try:
            entries = os.listdir(REPO_DIR)
            return [TextContent(type="text", text="\n".join(sorted(entries)))]
        except Exception as exc:
            return [TextContent(type="text", text=f"Error: {exc}")]

    elif name == "read_{{ repo_name_safe }}_file":
        fpath = os.path.join(REPO_DIR, arguments.get("path", ""))
        try:
            with open(fpath, "r") as f:
                return [TextContent(type="text", text=f.read()[:8000])]
        except Exception as exc:
            return [TextContent(type="text", text=f"Error: {exc}")]

    return [TextContent(type="text", text=f"Unknown tool: {name}")]


# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------
async def main():
    async with stdio_server() as (read, write):
        await app.run(read, write, app.create_initialization_options())

if __name__ == "__main__":
    asyncio.run(main())

