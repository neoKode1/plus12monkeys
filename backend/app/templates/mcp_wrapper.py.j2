"""MCP Server wrapper for {{ repo_name }} ({{ repo_url }}).

Auto-generated by +12 Monkeys — Code Mode MCP server.

Instead of one tool per operation, this server exposes just two tools:
  search()  — explore the repo structure, modules, and docs
  execute() — run Python code against the repo in a sandboxed namespace

This keeps the context window footprint fixed at ~500 tokens regardless
of how large or complex the wrapped repo is.  Inspired by the Cloudflare
Code Mode pattern (search + execute against a typed spec).

Usage:
    pip install -r requirements.txt
    python mcp_server.py
"""

import asyncio
import importlib
import io
import json
import logging
import os
import subprocess
import sys
import traceback
from contextlib import redirect_stdout, redirect_stderr
from pathlib import Path
from typing import Any, Dict, List

# ---------------------------------------------------------------------------
# MCP SDK imports  (pip install mcp)
# ---------------------------------------------------------------------------
from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import TextContent, Tool

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("{{ project_name }}-mcp")

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------
REPO_URL = "{{ repo_url }}"
REPO_DIR = os.environ.get("REPO_DIR", "./{{ repo_name }}")
MAX_OUTPUT = 8000  # truncate large outputs to stay context-friendly

# ---------------------------------------------------------------------------
# Tool metadata — UI feedback & safety classification
# Inspired by v0 (taskNameActive/Complete) and Windsurf (SafeToAutoRun).
# Consuming agents can read this to drive progress indicators and auto-run
# decisions without hard-coding tool names.
# ---------------------------------------------------------------------------
TOOL_METADATA = {
    "search": {
        "safety_level": "safe",          # read-only — auto-run OK
        "task_name_active": "Searching repository",
        "task_name_complete": "Searched repository",
    },
    "execute": {
        "safety_level": "moderate",      # runs code — log & proceed
        "task_name_active": "Executing code",
        "task_name_complete": "Executed code",
    },
}

app = Server("{{ project_name }}")


# ---------------------------------------------------------------------------
# Helper: ensure the wrapped repo is cloned and installed
# ---------------------------------------------------------------------------
def _ensure_repo():
    """Clone the repo if it doesn't exist locally, and install its deps."""
    if not os.path.isdir(REPO_DIR):
        logger.info("Cloning %s …", REPO_URL)
        subprocess.run(["git", "clone", REPO_URL, REPO_DIR], check=True)
    req_path = os.path.join(REPO_DIR, "requirements.txt")
    if os.path.exists(req_path):
        subprocess.run(
            [sys.executable, "-m", "pip", "install", "-r", req_path, "-q"],
            check=True,
        )
    if REPO_DIR not in sys.path:
        sys.path.insert(0, os.path.abspath(REPO_DIR))


_ensure_repo()


# ---------------------------------------------------------------------------
# Sandbox helpers for Code Mode
# ---------------------------------------------------------------------------
def _build_repo_manifest() -> Dict[str, Any]:
    """Build a searchable manifest of the repo structure."""
    manifest: Dict[str, Any] = {"files": [], "modules": [], "entry_points": []}
    repo = Path(REPO_DIR)
    for p in sorted(repo.rglob("*")):
        if p.is_file() and ".git" not in p.parts:
            rel = str(p.relative_to(repo))
            manifest["files"].append(rel)
            if rel.endswith(".py"):
                manifest["modules"].append(rel)
{% if entry_points %}
    manifest["entry_points"] = {{ entry_points | tojson }}
{% endif %}
    return manifest


def _safe_exec(code: str, namespace: Dict[str, Any]) -> str:
    """Execute Python code in a restricted namespace, capture output."""
    stdout_buf = io.StringIO()
    stderr_buf = io.StringIO()
    try:
        with redirect_stdout(stdout_buf), redirect_stderr(stderr_buf):
            exec(code, namespace)  # noqa: S102
        result = namespace.get("result", None)
        output = stdout_buf.getvalue()
        if result is not None:
            if isinstance(result, (dict, list)):
                output += json.dumps(result, indent=2, default=str)
            else:
                output += str(result)
        if not output:
            output = stderr_buf.getvalue() or "(no output — set `result = ...` to return data)"
        return output[:MAX_OUTPUT]
    except Exception:
        return traceback.format_exc()[:MAX_OUTPUT]



# ---------------------------------------------------------------------------
# Code Mode tools — just search + execute (~500 tokens total)
# ---------------------------------------------------------------------------

@app.list_tools()
async def list_tools() -> List[Tool]:
    """Advertise exactly 2 tools — the Code Mode pair."""
    return [
        Tool(
            name="search",
            description=(
                "Explore the {{ repo_name }} repository.  Write Python code that "
                "inspects the repo manifest, reads files, or lists modules.  "
                "Available in scope: `manifest` (dict with keys files, modules, "
                "entry_points), `repo` (pathlib.Path to repo root), `open`, "
                "`json`, `importlib`, `os`, `Path`.  "
                "Set `result = <value>` to return data."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "code": {
                        "type": "string",
                        "description": (
                            "Python code to explore the repo. Example:\n"
                            "  result = [f for f in manifest['files'] if f.endswith('.py')]\n"
                            "  result = (repo / 'README.md').read_text()[:2000]"
                        ),
                    },
                },
                "required": ["code"],
            },
        ),
        Tool(
            name="execute",
            description=(
                "Run Python code against {{ repo_name }}.  The repo is on "
                "sys.path so you can import its modules directly.  Available "
                "in scope: everything from search, plus `subprocess`, `sys`, "
                "`importlib`.  Set `result = <value>` to return data."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "code": {
                        "type": "string",
                        "description": (
                            "Python code to execute. Example:\n"
                            "  from my_module import run\n"
                            "  result = run(input_data='hello')"
                        ),
                    },
                },
                "required": ["code"],
            },
        ),
    ]


@app.call_tool()
async def call_tool(name: str, arguments: Dict[str, Any]) -> List[TextContent]:
    """Handle search and execute tool calls."""
    # Log tool summary for observability (Windsurf pattern)
    meta = TOOL_METADATA.get(name, {})
    logger.info("[%s] %s", name, meta.get("task_name_active", name))
    code = arguments.get("code", "")

    if name == "search":
        # Search namespace: manifest + read-only helpers
        namespace: Dict[str, Any] = {
            "__builtins__": {
                k: __builtins__[k] if isinstance(__builtins__, dict) else getattr(__builtins__, k)
                for k in (
                    "print", "len", "sorted", "list", "dict", "str", "int",
                    "float", "bool", "tuple", "set", "enumerate", "zip", "map",
                    "filter", "range", "isinstance", "hasattr", "getattr", "dir",
                    "type", "open", "repr", "min", "max", "sum", "any", "all",
                    "reversed", "ValueError", "TypeError", "KeyError",
                    "FileNotFoundError", "Exception",
                )
            },
            "manifest": _build_repo_manifest(),
            "repo": Path(REPO_DIR).resolve(),
            "Path": Path,
            "json": json,
            "os": os,
            "importlib": importlib,
        }
        output = _safe_exec(code, namespace)
        return [TextContent(type="text", text=output)]

    elif name == "execute":
        # Execute namespace: full access to repo + subprocess
        namespace = {
            "manifest": _build_repo_manifest(),
            "repo": Path(REPO_DIR).resolve(),
            "Path": Path,
            "json": json,
            "os": os,
            "sys": sys,
            "subprocess": subprocess,
            "importlib": importlib,
            "logging": logging,
            "logger": logger,
        }
        output = _safe_exec(code, namespace)
        return [TextContent(type="text", text=output)]

    return [TextContent(type="text", text=f"Unknown tool: {name}. Use 'search' or 'execute'.")]


# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------
async def main():
    async with stdio_server() as (read, write):
        await app.run(read, write, app.create_initialization_options())

if __name__ == "__main__":
    asyncio.run(main())
